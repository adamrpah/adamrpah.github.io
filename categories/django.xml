<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NP Complete Heart (Posts about django)</title><link>http://www.npcompleteheart.com/</link><description></description><atom:link href="http://www.npcompleteheart.com/categories/django.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 01 Mar 2018 19:09:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Things keep a-changing</title><link>http://www.npcompleteheart.com/posts/things-keep-a-changing.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div class="row"&gt;
&lt;div class="col-md-4"&gt;
    &lt;img src="http://www.npcompleteheart.com/images/tesla_time_travel.jpg"&gt;
&lt;/div&gt;
&lt;div class="col-md-8"&gt;
I guess my post on &lt;a src="http://www.npcompleteheart.com/posts/www.npcompleteheart.com/posts/django-and-mongodb-in-2015"&gt;Django and MongoDB in 2015&lt;/a&gt; 
was prophetic, because I just changed my website over last week. It seemed that everytime I wanted to post 
a blog it was from an IPython notebook, which either meant reconfiguring the site to display IPython notebooks 
and get the css right or keep on with the semi-arduous process of converting the notebook to html (writing 
out `pre` blocks and all that). At this point it made me feel like that barrier was keeping me from blogging. 
Since producing at least a blog per month is on my New Year's resolutions list I decided to change up the 
site to hopefully make it more conducive to me blogging.
&lt;br&gt;&lt;br&gt;
&lt;/div&gt;

&lt;!-- TEASER_END --&gt;
&lt;div class="col-md-12"&gt;
This time around, I really just wanted something simple that had IPython notebook support baked in
from the start. I wanted it to be lightweight, support markdown input (since it seemed like I'm the
last human alive writing in html and I could never remember the damn markdown symbols for that
reason), and I guess be a little bit anachronistic. For these reasons I just decided to go with
(Nikola)[www.getnikola.org]. It looked cool, sounded simple (loved the part in the tutorial that
just said, `don't read this tutorial, just start using`), and it seems like the darkhorse in the
race against Pelican. In any case, that was enough to persuade me to start using it.
&lt;br&gt;&lt;br&gt;
The switch was pretty simple with the exception of the fact that I had to edit all my old posts to
make them appear like I wanted on this website. I would write more, but there really wasn't much
more to it than what's contained in teh basic introduction. The only thing that really held me up
was getting Git Pages to work. Most of the methods written on the internet weren't working for me
so I just did the lazy thing and made a separate repository for Github to serve as my website.
&lt;br&gt;&lt;br&gt;

Most things made it over okay, with the only real holdovers being the D3 visualizations with
javascript. I know that it's possible to move them over using an IPython notebook I just haven't had
the time yet. Through this process I also found out that someone limited the Folium mapping package
to only 6 colors again for apparently no fucking reason! Yay open source! Oh, and I killed some
high-traffic pages that I hated just because, like how to make a volcano plot. It was just too old
and out of date.
&lt;br&gt;&lt;br&gt;

Otherwise, the website isn't completely up yet (I need to add the projects back in, maybe give the
detail pages on individual publications) and figure out how to get some more javascript working (I know
completely against the whole starting premise). 
&lt;/div&gt;
&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>web</category><guid>http://www.npcompleteheart.com/posts/things-keep-a-changing.html</guid><pubDate>Fri, 01 May 2015 13:50:41 GMT</pubDate></item><item><title>Django and MongoDB in 2015</title><link>http://www.npcompleteheart.com/posts/django-and-mongodb-in-2015.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div class="row"&gt;
&lt;div class="col-md-4"&gt;
&lt;img src="http://www.npcompleteheart.com/images/django.jpg"&gt;
&lt;/div&gt;
&lt;div class="col-md-8"&gt;
&lt;p&gt;
So believe it or not my post from 2013 on setting up a Django website with a MongoDB back-end is still one of my most visited pages. Actually that's not hard to believe, it's not like this site is a trove of content (but it's a goal for 2015 to get content more consistently up here!), but 2013 is more than ancient in technology times so I just wanted to do a quick revisit.
&lt;/p&gt;
&lt;/div&gt;

&lt;!-- TEASER_END --&gt;
&lt;div class="col-md-12"&gt;
&lt;h5&gt;Should I follow that blog post and set up a Django app with MongoDB?&lt;/h5&gt;
&lt;h5&gt;Hell no, definitely not now&lt;/h5&gt;

&lt;p&gt;
Admittedly, my website still uses it but that is out of pure laziness and a lack of desire to migrate/work up something new. As is, I'm pretty sure that I have another year and a half before there's a catastrophic problem or a new feature that I absolutely have to have before I need to redo it all. And therein lies the biggest problem with trying to go down this path.
&lt;/p&gt;

&lt;p&gt;
The reason that I wanted to use MongoDB so much was its native usage of JSON (well, BSON) so that I could quickly and easily store data or javascript code for quick on-the-fly visualizations. I wanted Django for its robust admin backend (still why I love it! Nothing else that I've used has anything quite as good). However, now with the newest version of PostgreSQL and its support of JSON as a column type it's possible to get everything I want out of a website using a traditional SQL database (actually the one that Heroku has always wanted you to use anyways). Granted, this means going back to the world of migrations will be a pain but it's easy enough concession to be back on the main branch of Django development.
&lt;/p&gt;

&lt;h5&gt;But what if I really want to put the two together still?&lt;/h5&gt;
&lt;p&gt;
There could still be a pretty valid reason why you want an easy admin interface and a NoSQL backend, but in that case I don't think any of the old instructions may still apply with all of the time that has passed. In all honesty, if you're not making a blog site (or you won't be blogging consistently like me, womp womp) I would suggest not using Django at all and using a custom flask app (which would be simple enough) instead and provide lots of flexibility. If you were tr Buying to make a site as a product, then I wouldn't recommend python at all then and recommend node.js due to the performance benefits. 
&lt;/p&gt;

&lt;p&gt;
All in all, it's hard to say what to do in this new world where static site generators are the new hot thing. I still like having the ability to write and save drafts on my website instead of being stuck to a checked out instance of my website (I switch computers and locations...too often still). But in any case, I still like using Heroku even if it is apart of the giant SalesForce conglomerate.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>web</category><guid>http://www.npcompleteheart.com/posts/django-and-mongodb-in-2015.html</guid><pubDate>Fri, 02 Jan 2015 14:46:17 GMT</pubDate></item><item><title>What is the structure of my Django app?</title><link>http://www.npcompleteheart.com/posts/what-is-the-structure-of-my-django-app.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;
This post is supposed to carry on from &lt;a href="http://www.npcompleteheart.com/post/django-nonrel-mongodb-mongohq-heroku/"&gt; setting up a Django app on Heroku with MongoDB &lt;/a&gt; and help fill in a hole from the MongoDB &lt;a href="http://docs.mongodb.org/manual/tutorial/write-a-tumblelog-application-with-django-mongodb-engine/"&gt; Tumblelog &lt;/a&gt; tutorial.  The biggest question is, what is my directory structure?  The tutorial jumps around a lot, assuming that you already know where everything should go.  So let's tackle that first.
&lt;/p&gt;

&lt;!-- TEASER_END --&gt;

&lt;h3&gt;What is the structure of my Django project?&lt;/h3&gt;

&lt;p&gt;
This is probably the only part that most people starting out that are familiar with programming but not Django or the web will need.  Here is what your directory structure for a Tumblelog should look like:

&lt;/p&gt;&lt;pre class="prettyprint lang-bash"&gt;
djangoapp/
|- .git/
|- .gitignore
|- venv/
|- requirements.txt
|- Procfile
|- djangoapp/
    |- __init__.py
    |- urls.py
    |- settings.py
    |- manage.py
    |- tumblelog/
        |- models.py
        |- views.py
        |- tests.py
        |- forms.py
|- media/
    |- robots.txt
    |- js/
    |- img/
    |- css/
|- templates/
    |- base.html
    |- _form.html
    |- tumblelog/
        |- post_detail.html
        |- post_list.html
&lt;/pre&gt;

If you fit that first description then this is all you probably wanted, so happy web app'ing!



&lt;h3&gt;How do I configure it?&lt;/h3&gt;

&lt;p&gt;
So the only two directories really left are the media and template directories.  Media contains pictures (in the img/ folder), javascript (I would suggest that would be applied on every page, in the js/ folder), and site-wide css to style it (you guessed it, in the css/ folder).  You can make a directory in here and use it in an ad-hoc fashion too, before I added a javascript field in my Post model I had a folder in "media/" called "d3-files/". In that "d3-files/" folder I put javascript to execute visualizations, supporting data and css, and I could call it on a post page like this:

&lt;/p&gt;&lt;pre class="prettyprint lang-html"&gt;
script type="text/javascript" src="/media/d3-files/time_series.js"
&lt;/pre&gt;

And to get the right path for media working, in settings.py we do:

&lt;pre class="prettyprint lang-python"&gt;
2 import os
3 #Tons of Code
49 # Absolute filesystem path to the directory that will hold user-uploaded files.
50 # Example: "/home/media/media.lawrence.com/media/"
51 MEDIA_ROOT = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../media/')
52 
53 # URL that handles the media served from MEDIA_ROOT. Make sure to use a
54 # trailing slash.
55 # Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
56 MEDIA_URL = '/media/'
&lt;/pre&gt;

and that's it.  Media to serve for all!  Just watch out, there's not a lot of space on Heroku for something like images. So you'll be better off hosting images elsewhere (photobucket, flickr, picasa, etc.) and embedding the tags in your posts.


&lt;p&gt;
Hopefully that helps in some fashion!
&lt;/p&gt;&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>tutorial</category><category>web</category><guid>http://www.npcompleteheart.com/posts/what-is-the-structure-of-my-django-app.html</guid><pubDate>Wed, 20 Mar 2013 12:27:44 GMT</pubDate></item><item><title>Auto-slugification, drafts, and cooler queries</title><link>http://www.npcompleteheart.com/posts/auto-slugification-drafts-and-cooler-queries.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;Or more accurately, the list of things that I did last night to spiffy up the site. So what did I do in reality?&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;h3&gt;Making slugs is boring, having slugs made is awesome&lt;/h3&gt;
&lt;p&gt;If you follow the MongoDB Tumblelog post you'll be starting with a website that is pretty functional. 
One of the things that it does do is it has you enter the slug field for each post in the admin section when you create it. 
What is a slug? It's the string in the url bar you see after "/post/" and it identifies the post location in the website. 
For me, and most of the time, we have the slug modelled after the post title so it is easily tracked. 
It's annoying though to re-enter the title normalized for slug usage.&lt;/p&gt;
&lt;p&gt;The first thing I tried was adding the prepopulated fields line to the &lt;code&gt;admin.py&lt;/code&gt; file. 
This was supposed to prepopulate a slug field for a Post model using this code:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;PostAdmin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;admin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ModelAdmin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
     &lt;span class="nx"&gt;prepopulated_fields&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"slug"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;,)}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;but the admin section wasn't happy with this. 
Posts entered without a slug would be flagged as having an error (due to omission of the slug field). 
Quick googling suggests that there could be a problem with using django 1.3, and maybe django non-rel, but I didn't dwell on it too long.
Instead I found django-autoslug. Installation is simple&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;pip install django-autoslug
pip freeze &amp;gt; requirements.txt
&lt;/pre&gt;


&lt;p&gt;and using it in the blog model is as easy as&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autoslug&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;AutoSlugField&lt;/span&gt;
&lt;span class="c1"&gt;#Other imports&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;slug&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AutoSlugField&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;populate_from&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'title'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;#Other model attributes&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;after that the slug field is removed from the admin section, slugs are automatically populated upon post addition, and the slugs are normalized to the title of the post. 
Awesome!&lt;/p&gt;
&lt;h3&gt;But I'm going to want to save partial work on the web content and query the heck out of the DB!&lt;/h3&gt;
&lt;p&gt;For the next part I just wanted to add a draft field to the Post model so I could write posts on the admin section, 
leave them half-finished but saved to the database so I could pick them up and finish them from anywhere. 
That's a really simple change to the model of course, just:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;models&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;Other&lt;/span&gt; &lt;span class="nx"&gt;model&lt;/span&gt; &lt;span class="nx"&gt;fields&lt;/span&gt;
    &lt;span class="nx"&gt;draft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;models&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BooleanField&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;blank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;help_text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Save as a draft on the server"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now what we could do is just handle the display of this in the template if need be. 
All posts are queried for when we want to display the list of available posts on the homepage. 
This is the 'ListView' from the Tumblelog tutorial and we could solve it in the template easily like this&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;post.draft&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  &amp;lt;--- Display post code --&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;but this doesn't really seem that great. We're still loading the data from the database, it's just not being displayed using the template. 
It feels like we should really go the extra step here.&lt;/p&gt;
&lt;p&gt;So what do you do? We should change the query in the url of course! Even better, let's get some real mongo access. 
In the blog models.py we can actually open up the ability to do a raw query using django_mongodb_engine by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django_mongodb_engine.contrib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MongoDBManager&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;#Other attributes&lt;/span&gt;
    &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MongoDBManager&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;and we can change our queryset in urls.py for the list view to be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;    url(r'^$', PostListView.as_view(
        queryset=Post.objects.raw_query({'draft': False}).order_by('created_at').reverse(),
        context_object_name="posts_list"),
        name="home"
    ),
&lt;/pre&gt;


&lt;p&gt;Whereas before it was:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;url(r'^$', PostListView.as_view(
    queryset=Post.objects.all().order_by('created_at').reverse(),
    context_object_name="posts_list"),
    name="home"
),
&lt;/pre&gt;


&lt;p&gt;What we've done is open up the raw_query field on objects. Now we can actually issue more complicated queries to the database. 
While not essential now, this will be very useful for more complicated models/data types in the future.&lt;/p&gt;
&lt;p&gt;And that was it, pretty fun, pretty simple, and fairly functional. As always this has been cribbed from the work of others and googling, 
I just didn't keep track of my sources that well last night.&lt;/p&gt;&lt;/div&gt;</description><category>django</category><category>web</category><guid>http://www.npcompleteheart.com/posts/auto-slugification-drafts-and-cooler-queries.html</guid><pubDate>Tue, 19 Mar 2013 19:01:25 GMT</pubDate></item><item><title>Django nonrel, MongoDB, MongoHQ, and Heroku</title><link>http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;So you want to make a Django app with a MongoDB backend? &lt;/p&gt;
&lt;p&gt;Better yet do you want to deploy to Heroku and use MongoHQ so there's minimal set up on your end and a free testing sandbox?&lt;/p&gt;
&lt;p&gt;That's what I've done with this site (which is why it can be unresponsive also, I'm using all free at the moment).&lt;br&gt;
After doing it once I thought I had it down pat in terms of my online sources and thought that I could replicate 
that success with minimal fuss.  I was just proven wrong when I went too far, too fast and borked my app into a 
state that I didn't know how to fix it out of.  So here is an actual step by step, both for myself and others.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;h3&gt;Update&lt;/h3&gt;
&lt;p&gt;This post survived for almost two months on the internet being correct about technology. Not too shabby. However, the wheels turn and things get outdated, namely that MongoDB was updated to 2.4 and changed behavior. By default all collections are capped and pymongo with the django fork wasn't handling that properly. If you follow the requirements list &lt;em&gt;exactly&lt;/em&gt; this will not work.  You need to update the version of PyMongo to version&amp;gt;2.5 for it to work. Happy Coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resume Old Post&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--------------&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So you want to make a Django app with a MongoDB backend? &lt;/p&gt;
&lt;p&gt;Better yet do you want to deploy to Heroku and use MongoHQ so there's minimal set up on your end and a free testing sandbox?&lt;/p&gt;
&lt;p&gt;That's what I've done with this site (which is why it can be unresponsive also, I'm using all free at the moment).  After doing it once I thought I had it down pat in terms of my online sources and thought that I could replicate that success with minimal fuss.  I was just proven wrong when I went too far, too fast and borked my app into a state that I didn't know how to fix it out of.  So here is an actual step by step, both for myself and others.&lt;/p&gt;
&lt;p&gt;But as with all my posts, I want to put out the relevant sites that I've used and am cribbing heavily from (I'm nothing without the google).  So these are where my references are from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="https://devcenter.heroku.com/articles/django"&gt;Heroku Guide to a Vanilla Django App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="http://www.gdovicak.com/2012/02/Django-Nonrel-and-MongoDB-on-Heroku"&gt;G. Dovicak's awesome stub on configuring MongoHQ settings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="http://docs.mongodb.org/manual/tutorial/write-a-tumblelog-application-with-django-mongodb-engine/"&gt;MongoDB's How to make a tumblelog tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Installing python, django-nonrel, and mongo support&lt;/h3&gt;
&lt;p&gt;Okay, so let's START!  First assumptions, you have python 2.7 with virtual environment installed as well as the &lt;a href="https://devcenter.heroku.com/articles/quickstart"&gt;heroku dev toolbelt&lt;/a&gt;. Okay, now that that is done we're going to taketh from the Heroku tutorial first and get the app started.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;mkdir djangoapp &amp;amp;&amp;amp; cd djangoapp
virtualenv venv --distribute
source venv/bin/activate
vi requirements.txt
pip install -r requirements.txt
&lt;/pre&gt;


&lt;p&gt;where you edit your requirements.txt file in vim and it then looks like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;distribute==0.6.24
wsgiref==0.1.2
git+git://github.com/django-nonrel/django-nonrel.git@master
git+git://github.com/django-nonrel/django-permission-backend-nonrel.git@master
git+https://github.com/adamrpah/mongodb-engine.git
djangotoolbox==0.9.2
pymongo==2.4
&lt;/pre&gt;


&lt;p&gt;I took the advice in G. Dovicak's post and forked/cloned mongodb-engine as a git repository just so it was locked.  I don't feel that this step is entirely necessary, but you can feel free to use that fork if you want (it's public).
Now we have Django nonrel and its supporting packages installed inside a virtual environment.  &lt;/p&gt;
&lt;h3&gt;Starting a Django App and deploying it to Heroku&lt;/h3&gt;

&lt;p&gt;Next we start the app:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
django-admin.py startproject djangoapp
&lt;/pre&gt;

&lt;p&gt;and let's check that it runs locally (checking at every step is how you make sure you haven't gone too far while borking something instrumental up).&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
python djangoapp/manage.py runserver
&lt;/pre&gt;

&lt;p&gt;Navigate to localhost:8000 in your web browser.  You should see a "It Works!" page.  Wooo! We have a Django app sans database now.&lt;/p&gt;
&lt;p&gt;So now let's get this app ready to ship out to Heroku.  To do that we need to create a Procfile that contains the process that Heroku should run. so we do:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
vi Procfile
&lt;/pre&gt;

&lt;p&gt;and then insert into the file:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
web python djangoapp/manage.py runserver 0.0.0.0:$PORT --noreload
&lt;/pre&gt;

&lt;p&gt;Next set up git with a proper gitignore, initialize the repository, add the files, and commit it.  Afterwards we work with heroku, creating a heroku app and pushing our django app repository to heroku.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
vi .gitignore
git init
git add .
git commit -m 'initial django app'
heroku create
git push heroku master
&lt;/pre&gt;

&lt;p&gt;.gitignore file contents&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
*.pyc
venv
*.swp
&lt;/pre&gt;

&lt;p&gt;Now let's start up the process so that there's a dyno serving the website, check the activity on the heroku app to make sure it works, and view the 'It Works!' Django page in a browser to confirm.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku ps:scale web=1
heroku ps 
-&amp;gt; Scaling web processes... done, now running 1
heroku open
&lt;/pre&gt;

&lt;p&gt;Perfect!  We've launched our app in Heroku now.  &lt;/p&gt;
&lt;h3&gt;Configuring MongoHQ settings with Django&lt;/h3&gt;

&lt;p&gt;Let's get that Mongo database working as a complement to our django app.  We do that by enabling the MongoHQ add-on.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku addons:add mongohq:sandbox
&lt;/pre&gt;

&lt;p&gt;Now we actually have to figure out &lt;em&gt;WHERE&lt;/em&gt; and &lt;em&gt;HOW&lt;/em&gt; to connect to our MongoHQ database.  We do that by running&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku config| grep "MONGOHQ"
-&amp;gt; MONGOHQ_URL:                  mongodb://USER:PASSWORD@linus.mongohq.com:PORT/APP_ID
&lt;/pre&gt;

&lt;p&gt;We see that the heroku config command gives us all of the pertinent connection information for our instance. Or as an even more explicit example, your where should look like:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku config| grep "MONGOHQ"
-&amp;gt; MONGOHQ_URL:                  mongodb://heroku:aaaaaaaaaaaaaaaaaaaaaaaaaa@linus.mongohq.com:10000/app55555
&lt;/pre&gt;

&lt;p&gt;Now we have to populate our django settings file with it.  Initially the database connection settings for your django app will look like this:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': '',                      # Or path to database file if using sqlite3.
 16         'USER': '',                      # Not used with sqlite3.
 17         'PASSWORD': '',                  # Not used with sqlite3.
 18         'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;We will change that to look like this using our heroku config settings:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django_mongodb_engine', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': 'APPID',                      # Or path to database file if using sqlite3.
 16         'USER': 'USER',                      # Not used with sqlite3.
 17         'PASSWORD': 'PASSWORD',                  # Not used with sqlite3.
 18         'HOST': 'mongodb://linus.mongohq.com/APPID',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': PORT,                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;Or using our super explicit example:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django_mongodb_engine', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': 'app55555',                      # Or path to database file if using sqlite3.
 16         'USER': 'heroku',                      # Not used with sqlite3.
 17         'PASSWORD': 'aaaaaaaaaaaaaaaaaaaaaaaaaa',                  # Not used with sqlite3.
 18         'HOST': 'mongodb://linus.mongohq.com/app55555',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': 10000,                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;Here are some important things to note, to make sure everyone is on the same page.  The USER will always be prepopulated as 'heroku', that's why I'm using it in our super explicit example.  So on line 16 it will look like&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
16         'USER': 'heroku',                      # Not used with sqlite3.
&lt;/pre&gt;

&lt;p&gt;even in your own settings. PASSWORD is a long string of numbers and digits, PORT is a 5 digit number, and APPID is app[0-9]{8} (app followed by 8 numbers). There is one important point to note and I screwed this up twice in a row on two different projects.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
To connect to the MongoDB database it needs a port number that is an integer. 
By default there are string quotes in the field.&lt;br&gt;
DO NOT USE THE STRING QUOTES.  PUT IT IN AS AN INTEGER.
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I have forgotten this both times, hopefully I (and who reads this) will not make the same mistake anymore. The last step is to comment out one line (line 115, 'django.contrib.sites') in the settings file to remove a default django behavior.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
111 INSTALLED_APPS = (
112     'django.contrib.auth',
113     'django.contrib.contenttypes',
114     'django.contrib.sessions',
115     #'django.contrib.sites',
116     'django.contrib.messages',
117     'django.contrib.staticfiles',
118     # Uncomment the next line to enable the admin:
119     # 'django.contrib.admin',
120     # Uncomment the next line to enable admin documentation:
121     # 'django.contrib.admindocs',
122 )
&lt;/pre&gt;

&lt;p&gt;If we don't do this django will try to enter a site document into the Mongo database with a primary key of '1', which Mongo will not like and will stop your database sync.  Now we just have to package up these settings changes and push to heroku as&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
git add .
git commit -m 'Configured settings file to work with MongoHQ'
git push heroku master
&lt;/pre&gt;

&lt;p&gt;and now we very simply start up the database using the remote heroku machine with&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku run python djangoapp/manage.py syncdb
&lt;/pre&gt;

&lt;p&gt;And we're there! Making a database user with a password finishes this round out.&lt;/p&gt;
&lt;h3&gt;Next Steps&lt;/h3&gt;

&lt;p&gt;Making models, templates, and so on as in the Mongo Tumblelog or do whatever you want!  You now have the base configuration to make a website.&lt;/p&gt;&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>tutorial</category><category>web</category><guid>http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html</guid><pubDate>Thu, 14 Mar 2013 12:21:25 GMT</pubDate></item></channel></rss>