<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NP Complete Heart (Posts about mongodb)</title><link>http://www.npcompleteheart.com/</link><description></description><atom:link href="http://www.npcompleteheart.com/categories/mongodb.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 01 Mar 2018 19:09:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Things keep a-changing</title><link>http://www.npcompleteheart.com/posts/things-keep-a-changing.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div class="row"&gt;
&lt;div class="col-md-4"&gt;
    &lt;img src="http://www.npcompleteheart.com/images/tesla_time_travel.jpg"&gt;
&lt;/div&gt;
&lt;div class="col-md-8"&gt;
I guess my post on &lt;a src="http://www.npcompleteheart.com/posts/www.npcompleteheart.com/posts/django-and-mongodb-in-2015"&gt;Django and MongoDB in 2015&lt;/a&gt; 
was prophetic, because I just changed my website over last week. It seemed that everytime I wanted to post 
a blog it was from an IPython notebook, which either meant reconfiguring the site to display IPython notebooks 
and get the css right or keep on with the semi-arduous process of converting the notebook to html (writing 
out `pre` blocks and all that). At this point it made me feel like that barrier was keeping me from blogging. 
Since producing at least a blog per month is on my New Year's resolutions list I decided to change up the 
site to hopefully make it more conducive to me blogging.
&lt;br&gt;&lt;br&gt;
&lt;/div&gt;

&lt;!-- TEASER_END --&gt;
&lt;div class="col-md-12"&gt;
This time around, I really just wanted something simple that had IPython notebook support baked in
from the start. I wanted it to be lightweight, support markdown input (since it seemed like I'm the
last human alive writing in html and I could never remember the damn markdown symbols for that
reason), and I guess be a little bit anachronistic. For these reasons I just decided to go with
(Nikola)[www.getnikola.org]. It looked cool, sounded simple (loved the part in the tutorial that
just said, `don't read this tutorial, just start using`), and it seems like the darkhorse in the
race against Pelican. In any case, that was enough to persuade me to start using it.
&lt;br&gt;&lt;br&gt;
The switch was pretty simple with the exception of the fact that I had to edit all my old posts to
make them appear like I wanted on this website. I would write more, but there really wasn't much
more to it than what's contained in teh basic introduction. The only thing that really held me up
was getting Git Pages to work. Most of the methods written on the internet weren't working for me
so I just did the lazy thing and made a separate repository for Github to serve as my website.
&lt;br&gt;&lt;br&gt;

Most things made it over okay, with the only real holdovers being the D3 visualizations with
javascript. I know that it's possible to move them over using an IPython notebook I just haven't had
the time yet. Through this process I also found out that someone limited the Folium mapping package
to only 6 colors again for apparently no fucking reason! Yay open source! Oh, and I killed some
high-traffic pages that I hated just because, like how to make a volcano plot. It was just too old
and out of date.
&lt;br&gt;&lt;br&gt;

Otherwise, the website isn't completely up yet (I need to add the projects back in, maybe give the
detail pages on individual publications) and figure out how to get some more javascript working (I know
completely against the whole starting premise). 
&lt;/div&gt;
&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>web</category><guid>http://www.npcompleteheart.com/posts/things-keep-a-changing.html</guid><pubDate>Fri, 01 May 2015 13:50:41 GMT</pubDate></item><item><title>MongoDB is for researchers</title><link>http://www.npcompleteheart.com/posts/mongodb-is-for-researchers.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div class="row"&gt;
&lt;div class="col-md-4"&gt;
&lt;img src="http://www.npcompleteheart.com/images/mongodb.jpeg"&gt;
&lt;/div&gt;
&lt;div class="col-md-8"&gt;
Over the past three years I’ve been something of an evangelist for using MongoDB. This stance has
drawn derision from some outside the lab, which frequently forces me to clarify in what
circumstances I think MongoDB (or NoSQL in general) is so great. Unfortunately, I’ve been too lazy
to put those thoughts into writing, so this is my long overdue explanation and the first in a series
of posts describing how I use MongoDB daily.
&lt;/div&gt;

&lt;!-- TEASER_END --&gt;

&lt;div class="col-md-12"&gt;
&lt;h3&gt;MongoDB is for &lt;strike&gt;lovers&lt;/strike&gt; researchers and scientists&lt;/h3&gt;

So I think the first question to tackle is why use a database at all? Here are the three basic
reasons that caused me to make a switch.
&lt;br&gt;&lt;br&gt;

&lt;li&gt;&lt;strong&gt;Speed.&lt;/strong&gt; If you’ve ever explored the parameter landscape of a model then you’ve likely
experienced the point when typing `ls *` in your results folder can bring your system to its knees.
While there are ways to work around this problem (creating subfolders, smart naming conventions to
get groups of files), you can also just switch to storing the results in a database. Databases are
designed for storing millions of records easily.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queries.&lt;/strong&gt; How many runs with parameters (rho, mu, sigma) have finished? Okay, now how many
of those runs have a final value of y? Not nearly as easy to answer is it? At best it would require
looking at the final line of every file. At worst, with some odd encoding scheme or additional forms
of output in the same file this could require parsing every file. Databases make answering these
types of questions quick and easy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Portability.&lt;/strong&gt; Your data files need to be in a specified directory for your code to read
it. A folder for all your results needs to be in the right place too. Any time you want to test your
code those parts all need to be there and hopefully the ‘there’ isn’t in the same folder as your
code (I am an unabashed proponent of separating code, data, and results). For me, switching between
a laptop, workstation, and two different clusters, this can lead to some annoying inconsistencies
with file availability (specifically with large data files). Storing your data in a database with a
static IP address makes it easy to access anywhere.&lt;/li&gt;
&lt;br&gt;&lt;br&gt;

This is the start to why I think it’s a good idea to use a database, with another lurking reason
being that working knowledge of databases is required outside academia. If none of those reasons
resonate with you to explore these options then don’t worry, not everyone has the same research
problems as me.
&lt;br&gt;&lt;br&gt;

&lt;h3&gt;So why X technology over Y technology?&lt;/h3&gt;

If you wade too far into the internet you’ll find out that MongoDB is a type of NoSQL database and
that other types of databases are SQL databases. If you wade even a little bit further then a
torrent of flame wars will come pouring out of your monitor and you should just shut your eyes,
cover your ears, and pull your computer’s power plug out. Hopefully the following reasons will make
it slightly clear what the differences are without having to go dive into the recesses of the
internet. 
&lt;br&gt;&lt;br&gt;

Ease of use - i.e. Schemaless. What does schemaless really mean?
When you use a SQL database you need to first create a database and then a table. Then once you
create a table you must give commands or use a GUI to establish the number of columns, the names of
columns, and, most importantly, the data type that each column can hold. When a record is entered
into the database it must have all those fields. If you decide to change your code and need to store
additional data fields then you must alter the table first (or else suffer an error!).
&lt;br&gt;&lt;br&gt;

With MongoDB you create a database and then insert a document into it. It will even lazily create
the collection that you told it to use. It can have any number of fields (or keys in Mongo/document
speak) and each key can be named however you want. The twist is when you go to insert a second
document. The second document doesn’t need the same number of keys, or key names, or even the
datatypes of the values associated with each key name. It allows you to do whatever at any time,
with any document in the database.
&lt;br&gt;&lt;br&gt;

Now this freedom is considered to be a flaw in some minds, but all I see is that the onus of
consistency is on the programmer (i.e. you). In the context of a single person, a small group, or a
research lab I don’t think that it’s much to expect that everyone act responsibly and document what
they’re doing (either in the README for the project and/or with explicit key names). The most
important thing to remember is that just about any technology can be detrimental to the workings of
a project if in the hands of an irresponsible idiot.
&lt;br&gt;&lt;br&gt;

&lt;h4&gt;Dictionaries!&lt;/h4&gt;

So this stems from being a pythonista, but when  I code I store things as dictionaries or classes
typically. MongoDB lets me shove that directly into the database since it works with natively with
dictionaries (Mongo’s data store is a BSON, which is more or less a JSON, which is almost a
dictionary). This isn’t so when working with a SQL database, since each record is stored in a row
(think of a CSV file), and for me this is a huge differentiation and selling point. 
&lt;br&gt;&lt;br&gt;

Complex data structures can be natively stored in MongoDB and they are directly returned when I
query them.  So for me, when I run a simulation and there is a class keeping track of the time
evolution of the system at the end of the run I can just calculate whatever additional metrics are
necessary and save the dictionary into the database. When I need to analyze the results I can either
roll directly with the dictionary and start analyzing, it’s pretty simple.
&lt;br&gt;&lt;br&gt;

&lt;h4&gt;Complex values.&lt;/h4&gt;
I have stored datetime as a value, which isn’t really that special. What is special is when I store
a networkx graph object. Mongo will let you shove a fair number of things into it without requiring
you to convert them to a string. This is not only handy, but it cuts out code and processing steps
on file loading.
&lt;br&gt;&lt;br&gt;

&lt;h4&gt;MapReduce.&lt;/h4&gt;
This is more of a footnote but MapReduce is a great feature and can turn 24 hours of computation
time into one fairly quickly. 
&lt;br&gt;&lt;br&gt;

These are the basic reasons why I use MongoDB, both in comparison to a file system and a SQL
database. I will never say that it’s the fastest or the best solution from a technical standpoint,
but it is the quickest and easiest solution in regards to my time, which is the most important thing
in my mind. I’m a researcher, not someone setting up production databases or something soul crushing
like that ;)
&lt;/div&gt;
&lt;/div&gt;</description><category>mongodb</category><category>research</category><guid>http://www.npcompleteheart.com/posts/mongodb-is-for-researchers.html</guid><pubDate>Tue, 31 Mar 2015 18:49:20 GMT</pubDate></item><item><title>Django and MongoDB in 2015</title><link>http://www.npcompleteheart.com/posts/django-and-mongodb-in-2015.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div class="row"&gt;
&lt;div class="col-md-4"&gt;
&lt;img src="http://www.npcompleteheart.com/images/django.jpg"&gt;
&lt;/div&gt;
&lt;div class="col-md-8"&gt;
&lt;p&gt;
So believe it or not my post from 2013 on setting up a Django website with a MongoDB back-end is still one of my most visited pages. Actually that's not hard to believe, it's not like this site is a trove of content (but it's a goal for 2015 to get content more consistently up here!), but 2013 is more than ancient in technology times so I just wanted to do a quick revisit.
&lt;/p&gt;
&lt;/div&gt;

&lt;!-- TEASER_END --&gt;
&lt;div class="col-md-12"&gt;
&lt;h5&gt;Should I follow that blog post and set up a Django app with MongoDB?&lt;/h5&gt;
&lt;h5&gt;Hell no, definitely not now&lt;/h5&gt;

&lt;p&gt;
Admittedly, my website still uses it but that is out of pure laziness and a lack of desire to migrate/work up something new. As is, I'm pretty sure that I have another year and a half before there's a catastrophic problem or a new feature that I absolutely have to have before I need to redo it all. And therein lies the biggest problem with trying to go down this path.
&lt;/p&gt;

&lt;p&gt;
The reason that I wanted to use MongoDB so much was its native usage of JSON (well, BSON) so that I could quickly and easily store data or javascript code for quick on-the-fly visualizations. I wanted Django for its robust admin backend (still why I love it! Nothing else that I've used has anything quite as good). However, now with the newest version of PostgreSQL and its support of JSON as a column type it's possible to get everything I want out of a website using a traditional SQL database (actually the one that Heroku has always wanted you to use anyways). Granted, this means going back to the world of migrations will be a pain but it's easy enough concession to be back on the main branch of Django development.
&lt;/p&gt;

&lt;h5&gt;But what if I really want to put the two together still?&lt;/h5&gt;
&lt;p&gt;
There could still be a pretty valid reason why you want an easy admin interface and a NoSQL backend, but in that case I don't think any of the old instructions may still apply with all of the time that has passed. In all honesty, if you're not making a blog site (or you won't be blogging consistently like me, womp womp) I would suggest not using Django at all and using a custom flask app (which would be simple enough) instead and provide lots of flexibility. If you were tr Buying to make a site as a product, then I wouldn't recommend python at all then and recommend node.js due to the performance benefits. 
&lt;/p&gt;

&lt;p&gt;
All in all, it's hard to say what to do in this new world where static site generators are the new hot thing. I still like having the ability to write and save drafts on my website instead of being stuck to a checked out instance of my website (I switch computers and locations...too often still). But in any case, I still like using Heroku even if it is apart of the giant SalesForce conglomerate.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>web</category><guid>http://www.npcompleteheart.com/posts/django-and-mongodb-in-2015.html</guid><pubDate>Fri, 02 Jan 2015 14:46:17 GMT</pubDate></item><item><title>A little something extra for managing PyMongo</title><link>http://www.npcompleteheart.com/posts/a-little-something-extra-for-managing-pymongo.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;
I really dislike boilerplate code, it drives me a little bit crazy. Starting database connections falls squarely into that realm. So in the vein of "sharing is caring" here is what I'm currently using with pymongo. It's pretty simple, but why code it twice right?
&lt;/p&gt;

&lt;!-- TEASER_END --&gt;

&lt;p&gt;
It's  pretty simple script that only contains one class: MongoConnection. It needs to be initialized with a dictionary containing the connection parameters (preferably stored in a config file that you're just feeding in) like so.
&lt;br&gt;
&lt;/p&gt;&lt;pre&gt;
settings = {
  'user' : 'username',
  'pasword' : 'password',
  'host' : 'hostname',
  'port' : 'port',
  'db': 'db_name',
  'collection': 'collection_name'
}

import MongoConnect as mcxn
dbConnection = mcxn.MongoConnection(settings)
&lt;/pre&gt;


&lt;p&gt;
With that it will have already initialized the specific database and collection needed, right away you can:
&lt;br&gt;
&lt;/p&gt;&lt;pre&gt;
#Insert a document
dbConnection.collection.insert({"body": "I am a sample document body", "name": "FunnyBunny"})
#Find that document!
dbConnection.collection.find({"name" : "FunnyBunny"})
#Close the connection to the database!
dbConnection.tearDown()
#Reopen it after closing it! Just go wild!
dbConnection.connect()
&lt;/pre&gt;


&lt;p&gt;
So that's about it.  There is some basic error handling, which is to say don't push it.
&lt;/p&gt;

&lt;p&gt;
The previous code is scratched, a new better version can be found in a &lt;a href="https://gist.github.com/adamrpah/18f67498daf8fb8573a3"&gt;gist&lt;/a&gt; that I will regularly update. Alternatively, you can just copy this &lt;a href="https://gist.githubusercontent.com/adamrpah/18f67498daf8fb8573a3/raw/15b11b9db449cf72b3e6870ddc7dbc3f0dd74b45/mongoConnect.py"&gt;url&lt;/a&gt; and use wget to download the script :)
&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>code</category><category>mongodb</category><category>pymongo</category><category>python</category><guid>http://www.npcompleteheart.com/posts/a-little-something-extra-for-managing-pymongo.html</guid><pubDate>Tue, 17 Dec 2013 12:46:48 GMT</pubDate></item><item><title>Wild unsupportable claims about how Product X sucks!</title><link>http://www.npcompleteheart.com/posts/wild-unsupportable-claims-about-how-product-x-sucks.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;I read an article in the last month that really rubbed me raw, it was this one:
&lt;br&gt;&lt;br&gt;
&lt;a href="http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/"&gt;Why you should never use MongoDB&lt;/a&gt;
&lt;br&gt;&lt;br&gt;
Why does it bother me so much? Mostly because it’s bullshit, but I also feel that NoSQL solutions (and MongoDB specifically) are getting an undue bad reputation due to “MongoDB/NoSQL is bad” articles making great link-bait. Even more than that, people present themselves as experts when in reality they just make extremely broad claims about a lack of suitability without properly defining what their REAL needs are that make a technology so poor. 
&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;
Why do I say that? Well this quote makes the point really well (emphasis mine):

 &lt;/p&gt;&lt;blockquote&gt;
Well, that’s the million dollar question. But I’ve already answered the billion-dollar question. In this post I’ve talked about how we used MongoDB vs. how it was designed to be used. I’ve talked about it as though all that information were obvious, and &lt;strong&gt;the Diaspora team just failed to research adequately before choosing&lt;/strong&gt;.
&lt;br&gt;
But this stuff wasn’t obvious at all. The MongoDB docs tell you what it’s good at, without emphasizing what it’s not good at. That’s natural. All projects do that. But as a result, it took us about six months, a lot of user complaints, and a lot of investigation to figure out that we were using MongoDB the wrong way.
&lt;/blockquote&gt;

Is it really the fault of the database that a team didn’t research a solution they implemented first? I don’t think so. Especially when the crux of their problem was the fact that no one thought of how to model relationships within a document database before even beginning.


&lt;p&gt;
Modelling relationships within MongoDB actually isn’t that hard, there’s a few options available and even I’ve been able to write about them &lt;a href="http://www.npcompleteheart.com/posts/%E2%80%9Dhttp:/www.npcompleteheart.com/post/starting-with-mongo-some-dos-and-donts/%E2%80%9D"&gt;before&lt;/a&gt;. The problem is that the team didn’t want  to bake this part into the code (understandable, but that’s another unstated project need that isn’t a fault of NoSQL) and maintain in light of their familiarity with a traditional SQL backend. Again, that’s a personal choice based on project needs, not a major failing in a database backend.
&lt;/p&gt;

&lt;p&gt;
So let’s look at the real needs again:
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Needs to be a solution that integrates with some type of ORM for database interaction so relational joining is not in application code&lt;/li&gt;
&lt;li&gt;Not duplicating data in the database (because hard disk space is precious? because it’s 1999 again?)&lt;/li&gt;
&lt;li&gt;Needs to be familiar enough that team members have prior experience in optimization and usage&lt;/li&gt;
&lt;/ul&gt;

Given that criteria, MongoDB was a horrible solution. The reality is that anything but a traditional SQL backend would have been a terrible decision. But none of those are valid reasons as to &lt;strong&gt;”Why you should never use MongoDB”&lt;/strong&gt;.


&lt;p&gt;
The real lesson is that you should never decide on which technologies a new project will use without discussing your possible needs beforehand. This goes not only for new technologies, but also continuing to use existing technologies. Just like NoSQL isn’t for everything, neither is SQL. It’s just that either one can be forced to work as a solution and be painful to work with for the entire project lifespan.
&lt;/p&gt;

&lt;p&gt;
You reap what you sow, so don’t be lazy. That’s the entire take-away, pretty damn simple right?
&lt;/p&gt;&lt;/div&gt;</description><category>databases</category><category>mongodb</category><category>soapbox</category><guid>http://www.npcompleteheart.com/posts/wild-unsupportable-claims-about-how-product-x-sucks.html</guid><pubDate>Wed, 11 Dec 2013 12:45:46 GMT</pubDate></item><item><title>Starting with Mongo, some Dos and Don'ts</title><link>http://www.npcompleteheart.com/posts/starting-with-mongo-some-dos-and-donts.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;
Some backstory.  I think I first started talking about MongoDB in earnest maybe five months ago in my research lab. After having one person convert with a big project and some successful presentations (which weren't even done by me!) research has finally peaked.  Now that everyone is converting, people are going through the same growing pains I had when I first started. Instead of forgetting these nuggets of information again I wanted to put them done in text.
&lt;/p&gt;

&lt;!-- TEASER_END --&gt;

&lt;h3&gt;Wait, why MongoDB? I heard about (blank)! ...or Something new? Bah... Screw it.&lt;/h3&gt;

&lt;p&gt;
I'm just going to be blunt, I am not the person to have an argument about SQL versus NoSQL or NoSQL option a vs NoSQL option b. There are tons of software technologies, both old and new, and I think that whatever fits your specific use case for a single problem is what you should do. To me, that means that if you are trying to run a High Frequency Trading firm you have a really expensive SQL server, if you are maintaining secondary indices you have Redis, or if you have tons of database document records you use MongoDB or something close to it. My vote is for using whatever software best fits the problem at hand.  With that said though, I am going to approach the basics of MongoDB coming from a comparison to SQL.
&lt;/p&gt;

&lt;h3&gt;Some Mongo Basics&lt;/h3&gt;

&lt;p&gt;
A mongo install will/can have many databases inside of it. Each database will/can in turn host many collections. Each collection hosts a number of records which are termed BSONs (Binary JSON) which are similar to JSONs (JavaScript Object Notation) which are similar to dictionaries in a programming language like Python. Like every other dictionary, a BSON will be composed of keys and values. To put this in SQL terms, the column headings would be keys and the values in a single row would be the values. Each row would be a separate record.
&lt;/p&gt;

&lt;p&gt;
At this point, you may have already noticed something. "But wait, aren't you duplicating the entry for those keys? Isn't that a waste of space?'
&lt;br&gt;
The answer is yes, that is inefficient in terms of disk space.  However, it is not inefficient in terms of querying.  Every time I launch a search for a record I will want to know what are the fields that the record has and access them. This is especially true because each record doesn't need to have the same schema. The real answer in all of this, is to not worry about space inefficiencies. Horizontal scaling of MongoDB (spreading it over multiple computers to increase space) is easily done.  It's a little bit of a paradigm shift, but let's just roll with it.
&lt;/p&gt;

&lt;p&gt;
For the rest of this walkthrough, when I talk about interacting with the database I'll be referring to it as if we are using python with PyMongo to access the database. You could just execute commands with the Mongo shell but we'll work with it this way.
&lt;/p&gt;

&lt;h3&gt;What is my MongoDB workflow?&lt;/h3&gt;

&lt;p&gt;
First off, databases and collections in MongoDB are lazily created.  That means that when you tell mongo that you are going to put something into a database or collection that doesn't exist, it creates it! It also means that just telling it to open a database doesn't create it.  MongoDB won't actually create the database until there is a BSON in there.
&lt;/p&gt;

&lt;p&gt;
So let's make the worst address book as an example.  We'll assume that we have MongoDB running on the computer where we are typing this code. From the interactive python shell, it will look something like this;

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
import pymongo
client = pymongo.MongoClient()
db = client.address_book
db.friends.insert({'name': 'John'})
&amp;gt; ObjectId('5183fb1aacc1453c8e5258f4')
&lt;/pre&gt;
&lt;br&gt;

What we have done here is:
&lt;ul&gt;
&lt;li&gt; Imported pymongo &lt;/li&gt;
&lt;li&gt; Established a connection to MongoDB&lt;/li&gt;
&lt;li&gt; Created a database called 'address_book'.  After this first time, we will not be creating but just calling it because it will already exist&lt;/li&gt;
&lt;li&gt; Inserted an entry for our friend 'John' into the collection 'friends' inside the database 'address_book'.  Mongo responds by telling us what the ObjectId it has assigned to it is. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
This ObjectId is uniquely created for each document and this is how Mongo keeps track of the documents on its own. It is actually quite important too. Let's find our document in the database and look at how Mongo keeps it.

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
db.friends.find_one()
&amp;gt; {u'_id': ObjectId('5183fb1aacc1453c8e5258f4'), u'name': u'John'}
&lt;/pre&gt;
&lt;br&gt;

We see here that the ObjectId is the value of the field '_id'.  This is actually important: &lt;b&gt;Mongo reserves the value 'id'/'_id' to itself.&lt;/b&gt;  You can actually create an 'id' field of your own, but you won't be able to index it (see the next section for why that is important).  It's best to be more expressive in your key naming anyways, given that we can have tons of documents of any type in a collection.  In this example, we will give our documents a 'friend_id' to uniquely identify them.


&lt;p&gt;
Adding our friend_id is relatively easy.  We just get the corresponding record, modify it, and then save it back in the database.  This is done as:

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
friend_bson = db.friends.find({'name': 'John'})[0]
friend_bson['friend_id'] = 1
db.friends.save(friend_bson)
db.friends.find_one()
&amp;gt; {u'friend_id': 1, u'_id': ObjectId('5183fb1aacc1453c8e5258f4'), u'name': u'John'}
&lt;/pre&gt;
&lt;br&gt;

We find the document we want (note that we put an index on the find because without it friend_bson would be the cursor to the database query), add the new field, and then save it.  MongoDB sees that it has an ObjectId already and matches it to the document in the database. Pretty simple right?  Now just make sure not to mess with an ObjectId. 


&lt;h3&gt;Why is MongoDB so slow after I put in a bunch of records?&lt;/h3&gt;

&lt;p&gt;
So let's continue with our example and say that you have created a database and populated it with thousands of BSONs that catalog your friends' information (we all have thousands of friends after Facebook right?). But now you want to find a specific friend and view their information.  We would launch a query like (note that 'find_one()' is a pymongo specific query):

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
friend = db.friends.find({'name': 'John'})
print friend
&amp;gt; {'_id': ObjectId(88719352718910), 'name': 'John'}
&lt;/pre&gt;
&lt;br&gt;

This will return the document of information that we have for our friend John. Now this request may take a bit of time, if we haven't touched our database at all.  That is because without telling Mongo additional fields that we want it to index, it will only index the "_id" field. This means that a query on any other field will send Mongo searching through all of the records one by one until it finds yours.


&lt;p&gt;
This is actually a pretty easy problem to fix.  All we have to do is tell Mongo to index on the field that we want to query on.  We do this in pymongo as:

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
db.friends.ensure_index('name')
&lt;/pre&gt;
&lt;br&gt;

I like to actually put this line of code at the end of my initial data import script.  That way I don't forget to do it and have slow query times.


&lt;p&gt;
Now you might ask why not just index all of the fields then?  The way that indexing in Mongo works is that it keeps a tree of all the values for an indexed field in memory. That way when you query it only has to traverse the tree to find your document.  If you index all of the fields you run the risk of having so many trees that are so large that exceeds the available memory of the computer.  That will send your performance right back down. So it's best to only index the fields that you will need to use.
&lt;/p&gt;

&lt;h3&gt;Many-to-Many Relationships&lt;/h3&gt;

&lt;p&gt;
One of the questions coming from SQL is how do I manage one-to-many or many-to-many relationships without tables? This is a good question and I don't believe that there is a set in stone answer yet.  Really it will come down to your use case. There are three ways that we can handle this: (1) document mapping, (2) embedded lists, and (3) embedded documents.
&lt;/p&gt;

&lt;p&gt;
In this example, we will say that we want to start adding where our friends work.  We will also assume that our friends are industrious and have more than one job.  So for example, we'll say that John works at both Northwestern University and MegaCorp. In this instance, we already have our friend John in the database.  Let's assume that we have already added a document for Northwestern University and MegaCorp into the database also.
&lt;/p&gt;

&lt;h4&gt;Document Mapping&lt;/h4&gt;

&lt;p&gt;
This is the most SQL-like manner.  We will create another document that has two fields, one that corresponds to John and another that corresponds to the corporation. That means we would do this:

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
relationship1 = {'person_name' : 'John', 'corporation_name' : 'Northwestern University', 'type': 'relationship'})
relationship2 = {'person_name': 'John', 'corporation_name': 'MegaCorp', 'type':'relationship'})
db.friends.insert(relationship1)
db.friends.insert(relationship2)
&lt;/pre&gt;
&lt;br&gt;

Now for a random document to find their workplace we need to do:
&lt;pre class="prettyprint lang-python"&gt;
for document in db.friends.find('friend_id': {'$exists' : 'true'}}):
    corporations = []
    for relationship_record in db.friends.find({'type': 'relationship', 'person_name': document['name']}):
        corporations.append(relationship_record['corporation_name'])
print corporations
&amp;gt; ['Northwestern University', 'MegaCorp']
&lt;/pre&gt;
&lt;br&gt;

This method will require two queries to the database and multiple indices to ensure speed. If we didn't put the descriptive variable we want in the relationship record (which will be likely) then it would be three queries because we have to make another request to get the company record.  This will be the slowest option.


&lt;h4&gt;Embedded Lists&lt;/h4&gt;

&lt;p&gt;
Using this method we create a field in the person document called 'corporations' that is a list.  We then populate the list with the identifiers for our corporations. We will also do this to our corporation documents but in reverse, adding a field 'employees' that is a list of the people that work there. Given this set up our workflow would be:

&lt;/p&gt;&lt;pre class="prettyprint lang-python"&gt;
for document in db.friends.find('friend_id': {'$exists' : 'true'}}):
    print document['corporations']
&amp;gt; ['Northwestern University', 'MegaCorp']
&lt;/pre&gt;
&lt;br&gt;

In this set up, we only need one query.  If we didn't store the name of the corporation but instead the ObjectId we would have to query twice, once to get people and a second time to get corporations.  In any case, it would still be faster than the relationship mapping method.


&lt;h4&gt;Embedded Documents&lt;/h4&gt;

&lt;p&gt;
This method is an alternative take on embedded lists.  The only difference is, instead of storing a value to identify the associated company with we have the entire company document in the person document. This means that there is no need to have company records at all.  However, that means that the company information will be replicated separately in each one of the person documents (remember how I told you to not worry about disk space? This is the time).
&lt;/p&gt;

&lt;h4&gt;Choosing between them&lt;/h4&gt;

&lt;p&gt;
The Embedded Documents method can be a boon to speed or it can be a real pain and it really comes down to our usage.  For something like our address book, it makes more sense to use embedded lists.  That is because if we need to change a corporation (or person record) all we have is a pointer stored to it so there's no need to change it in more than one place.  If we use the embedded documents method, this would be a real pain.  Say for example that we added the address to a corporation, we would have to go through every person, see if they have that corporation listed, and change the address.  It's a time waste and overly redundant.
&lt;/p&gt;

&lt;p&gt;
However, on this blog I have each post as a document and any comments on that post are embedded into that post document. This makes sense, because whenever I want to load a blog post I also want the associated comments.  This makes it so that all the information I need is in one query.  Even better, a comment on one post doesn't apply to another so there isn't any real duplication.
&lt;/p&gt;

&lt;p&gt;
As a quick rule, I would say that the method that you use should be based on a specific use case.  If you have unique documents and a one-to-many relationship (like this blog and comments) then the Embedded Documents method makes sense.  If you have non-unique documents and relationships or many-to-many relationships then the Embedded Lists method will work better.  I honestly can't think of a situation where you would want to map the relationships in a SQL-like manner, but I reserve the right to be proven wrong.
&lt;/p&gt;

&lt;p&gt;
...and with that, good luck and happy Mongo'ing!
&lt;/p&gt;&lt;/div&gt;</description><category>mongodb</category><category>tutorial</category><guid>http://www.npcompleteheart.com/posts/starting-with-mongo-some-dos-and-donts.html</guid><pubDate>Thu, 02 May 2013 12:38:44 GMT</pubDate></item><item><title>What is the structure of my Django app?</title><link>http://www.npcompleteheart.com/posts/what-is-the-structure-of-my-django-app.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;
This post is supposed to carry on from &lt;a href="http://www.npcompleteheart.com/post/django-nonrel-mongodb-mongohq-heroku/"&gt; setting up a Django app on Heroku with MongoDB &lt;/a&gt; and help fill in a hole from the MongoDB &lt;a href="http://docs.mongodb.org/manual/tutorial/write-a-tumblelog-application-with-django-mongodb-engine/"&gt; Tumblelog &lt;/a&gt; tutorial.  The biggest question is, what is my directory structure?  The tutorial jumps around a lot, assuming that you already know where everything should go.  So let's tackle that first.
&lt;/p&gt;

&lt;!-- TEASER_END --&gt;

&lt;h3&gt;What is the structure of my Django project?&lt;/h3&gt;

&lt;p&gt;
This is probably the only part that most people starting out that are familiar with programming but not Django or the web will need.  Here is what your directory structure for a Tumblelog should look like:

&lt;/p&gt;&lt;pre class="prettyprint lang-bash"&gt;
djangoapp/
|- .git/
|- .gitignore
|- venv/
|- requirements.txt
|- Procfile
|- djangoapp/
    |- __init__.py
    |- urls.py
    |- settings.py
    |- manage.py
    |- tumblelog/
        |- models.py
        |- views.py
        |- tests.py
        |- forms.py
|- media/
    |- robots.txt
    |- js/
    |- img/
    |- css/
|- templates/
    |- base.html
    |- _form.html
    |- tumblelog/
        |- post_detail.html
        |- post_list.html
&lt;/pre&gt;

If you fit that first description then this is all you probably wanted, so happy web app'ing!



&lt;h3&gt;How do I configure it?&lt;/h3&gt;

&lt;p&gt;
So the only two directories really left are the media and template directories.  Media contains pictures (in the img/ folder), javascript (I would suggest that would be applied on every page, in the js/ folder), and site-wide css to style it (you guessed it, in the css/ folder).  You can make a directory in here and use it in an ad-hoc fashion too, before I added a javascript field in my Post model I had a folder in "media/" called "d3-files/". In that "d3-files/" folder I put javascript to execute visualizations, supporting data and css, and I could call it on a post page like this:

&lt;/p&gt;&lt;pre class="prettyprint lang-html"&gt;
script type="text/javascript" src="/media/d3-files/time_series.js"
&lt;/pre&gt;

And to get the right path for media working, in settings.py we do:

&lt;pre class="prettyprint lang-python"&gt;
2 import os
3 #Tons of Code
49 # Absolute filesystem path to the directory that will hold user-uploaded files.
50 # Example: "/home/media/media.lawrence.com/media/"
51 MEDIA_ROOT = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../media/')
52 
53 # URL that handles the media served from MEDIA_ROOT. Make sure to use a
54 # trailing slash.
55 # Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
56 MEDIA_URL = '/media/'
&lt;/pre&gt;

and that's it.  Media to serve for all!  Just watch out, there's not a lot of space on Heroku for something like images. So you'll be better off hosting images elsewhere (photobucket, flickr, picasa, etc.) and embedding the tags in your posts.


&lt;p&gt;
Hopefully that helps in some fashion!
&lt;/p&gt;&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>tutorial</category><category>web</category><guid>http://www.npcompleteheart.com/posts/what-is-the-structure-of-my-django-app.html</guid><pubDate>Wed, 20 Mar 2013 12:27:44 GMT</pubDate></item><item><title>Django nonrel, MongoDB, MongoHQ, and Heroku</title><link>http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html</link><dc:creator>Adam Pah</dc:creator><description>&lt;div&gt;&lt;p&gt;So you want to make a Django app with a MongoDB backend? &lt;/p&gt;
&lt;p&gt;Better yet do you want to deploy to Heroku and use MongoHQ so there's minimal set up on your end and a free testing sandbox?&lt;/p&gt;
&lt;p&gt;That's what I've done with this site (which is why it can be unresponsive also, I'm using all free at the moment).&lt;br&gt;
After doing it once I thought I had it down pat in terms of my online sources and thought that I could replicate 
that success with minimal fuss.  I was just proven wrong when I went too far, too fast and borked my app into a 
state that I didn't know how to fix it out of.  So here is an actual step by step, both for myself and others.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;h3&gt;Update&lt;/h3&gt;
&lt;p&gt;This post survived for almost two months on the internet being correct about technology. Not too shabby. However, the wheels turn and things get outdated, namely that MongoDB was updated to 2.4 and changed behavior. By default all collections are capped and pymongo with the django fork wasn't handling that properly. If you follow the requirements list &lt;em&gt;exactly&lt;/em&gt; this will not work.  You need to update the version of PyMongo to version&amp;gt;2.5 for it to work. Happy Coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resume Old Post&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--------------&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So you want to make a Django app with a MongoDB backend? &lt;/p&gt;
&lt;p&gt;Better yet do you want to deploy to Heroku and use MongoHQ so there's minimal set up on your end and a free testing sandbox?&lt;/p&gt;
&lt;p&gt;That's what I've done with this site (which is why it can be unresponsive also, I'm using all free at the moment).  After doing it once I thought I had it down pat in terms of my online sources and thought that I could replicate that success with minimal fuss.  I was just proven wrong when I went too far, too fast and borked my app into a state that I didn't know how to fix it out of.  So here is an actual step by step, both for myself and others.&lt;/p&gt;
&lt;p&gt;But as with all my posts, I want to put out the relevant sites that I've used and am cribbing heavily from (I'm nothing without the google).  So these are where my references are from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="https://devcenter.heroku.com/articles/django"&gt;Heroku Guide to a Vanilla Django App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="http://www.gdovicak.com/2012/02/Django-Nonrel-and-MongoDB-on-Heroku"&gt;G. Dovicak's awesome stub on configuring MongoHQ settings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html" title="http://docs.mongodb.org/manual/tutorial/write-a-tumblelog-application-with-django-mongodb-engine/"&gt;MongoDB's How to make a tumblelog tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Installing python, django-nonrel, and mongo support&lt;/h3&gt;
&lt;p&gt;Okay, so let's START!  First assumptions, you have python 2.7 with virtual environment installed as well as the &lt;a href="https://devcenter.heroku.com/articles/quickstart"&gt;heroku dev toolbelt&lt;/a&gt;. Okay, now that that is done we're going to taketh from the Heroku tutorial first and get the app started.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;mkdir djangoapp &amp;amp;&amp;amp; cd djangoapp
virtualenv venv --distribute
source venv/bin/activate
vi requirements.txt
pip install -r requirements.txt
&lt;/pre&gt;


&lt;p&gt;where you edit your requirements.txt file in vim and it then looks like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;distribute==0.6.24
wsgiref==0.1.2
git+git://github.com/django-nonrel/django-nonrel.git@master
git+git://github.com/django-nonrel/django-permission-backend-nonrel.git@master
git+https://github.com/adamrpah/mongodb-engine.git
djangotoolbox==0.9.2
pymongo==2.4
&lt;/pre&gt;


&lt;p&gt;I took the advice in G. Dovicak's post and forked/cloned mongodb-engine as a git repository just so it was locked.  I don't feel that this step is entirely necessary, but you can feel free to use that fork if you want (it's public).
Now we have Django nonrel and its supporting packages installed inside a virtual environment.  &lt;/p&gt;
&lt;h3&gt;Starting a Django App and deploying it to Heroku&lt;/h3&gt;

&lt;p&gt;Next we start the app:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
django-admin.py startproject djangoapp
&lt;/pre&gt;

&lt;p&gt;and let's check that it runs locally (checking at every step is how you make sure you haven't gone too far while borking something instrumental up).&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
python djangoapp/manage.py runserver
&lt;/pre&gt;

&lt;p&gt;Navigate to localhost:8000 in your web browser.  You should see a "It Works!" page.  Wooo! We have a Django app sans database now.&lt;/p&gt;
&lt;p&gt;So now let's get this app ready to ship out to Heroku.  To do that we need to create a Procfile that contains the process that Heroku should run. so we do:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
vi Procfile
&lt;/pre&gt;

&lt;p&gt;and then insert into the file:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
web python djangoapp/manage.py runserver 0.0.0.0:$PORT --noreload
&lt;/pre&gt;

&lt;p&gt;Next set up git with a proper gitignore, initialize the repository, add the files, and commit it.  Afterwards we work with heroku, creating a heroku app and pushing our django app repository to heroku.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
vi .gitignore
git init
git add .
git commit -m 'initial django app'
heroku create
git push heroku master
&lt;/pre&gt;

&lt;p&gt;.gitignore file contents&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
*.pyc
venv
*.swp
&lt;/pre&gt;

&lt;p&gt;Now let's start up the process so that there's a dyno serving the website, check the activity on the heroku app to make sure it works, and view the 'It Works!' Django page in a browser to confirm.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku ps:scale web=1
heroku ps 
-&amp;gt; Scaling web processes... done, now running 1
heroku open
&lt;/pre&gt;

&lt;p&gt;Perfect!  We've launched our app in Heroku now.  &lt;/p&gt;
&lt;h3&gt;Configuring MongoHQ settings with Django&lt;/h3&gt;

&lt;p&gt;Let's get that Mongo database working as a complement to our django app.  We do that by enabling the MongoHQ add-on.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku addons:add mongohq:sandbox
&lt;/pre&gt;

&lt;p&gt;Now we actually have to figure out &lt;em&gt;WHERE&lt;/em&gt; and &lt;em&gt;HOW&lt;/em&gt; to connect to our MongoHQ database.  We do that by running&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku config| grep "MONGOHQ"
-&amp;gt; MONGOHQ_URL:                  mongodb://USER:PASSWORD@linus.mongohq.com:PORT/APP_ID
&lt;/pre&gt;

&lt;p&gt;We see that the heroku config command gives us all of the pertinent connection information for our instance. Or as an even more explicit example, your where should look like:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku config| grep "MONGOHQ"
-&amp;gt; MONGOHQ_URL:                  mongodb://heroku:aaaaaaaaaaaaaaaaaaaaaaaaaa@linus.mongohq.com:10000/app55555
&lt;/pre&gt;

&lt;p&gt;Now we have to populate our django settings file with it.  Initially the database connection settings for your django app will look like this:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': '',                      # Or path to database file if using sqlite3.
 16         'USER': '',                      # Not used with sqlite3.
 17         'PASSWORD': '',                  # Not used with sqlite3.
 18         'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;We will change that to look like this using our heroku config settings:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django_mongodb_engine', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': 'APPID',                      # Or path to database file if using sqlite3.
 16         'USER': 'USER',                      # Not used with sqlite3.
 17         'PASSWORD': 'PASSWORD',                  # Not used with sqlite3.
 18         'HOST': 'mongodb://linus.mongohq.com/APPID',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': PORT,                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;Or using our super explicit example:&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
 12 DATABASES = {
 13     'default': {
 14         'ENGINE': 'django_mongodb_engine', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
 15         'NAME': 'app55555',                      # Or path to database file if using sqlite3.
 16         'USER': 'heroku',                      # Not used with sqlite3.
 17         'PASSWORD': 'aaaaaaaaaaaaaaaaaaaaaaaaaa',                  # Not used with sqlite3.
 18         'HOST': 'mongodb://linus.mongohq.com/app55555',                      # Set to empty string for localhost. Not used with sqlite3.
 19         'PORT': 10000,                      # Set to empty string for default. Not used with sqlite3.
 20     }
 21 }
&lt;/pre&gt;

&lt;p&gt;Here are some important things to note, to make sure everyone is on the same page.  The USER will always be prepopulated as 'heroku', that's why I'm using it in our super explicit example.  So on line 16 it will look like&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
16         'USER': 'heroku',                      # Not used with sqlite3.
&lt;/pre&gt;

&lt;p&gt;even in your own settings. PASSWORD is a long string of numbers and digits, PORT is a 5 digit number, and APPID is app[0-9]{8} (app followed by 8 numbers). There is one important point to note and I screwed this up twice in a row on two different projects.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
To connect to the MongoDB database it needs a port number that is an integer. 
By default there are string quotes in the field.&lt;br&gt;
DO NOT USE THE STRING QUOTES.  PUT IT IN AS AN INTEGER.
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I have forgotten this both times, hopefully I (and who reads this) will not make the same mistake anymore. The last step is to comment out one line (line 115, 'django.contrib.sites') in the settings file to remove a default django behavior.&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
111 INSTALLED_APPS = (
112     'django.contrib.auth',
113     'django.contrib.contenttypes',
114     'django.contrib.sessions',
115     #'django.contrib.sites',
116     'django.contrib.messages',
117     'django.contrib.staticfiles',
118     # Uncomment the next line to enable the admin:
119     # 'django.contrib.admin',
120     # Uncomment the next line to enable admin documentation:
121     # 'django.contrib.admindocs',
122 )
&lt;/pre&gt;

&lt;p&gt;If we don't do this django will try to enter a site document into the Mongo database with a primary key of '1', which Mongo will not like and will stop your database sync.  Now we just have to package up these settings changes and push to heroku as&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
git add .
git commit -m 'Configured settings file to work with MongoHQ'
git push heroku master
&lt;/pre&gt;

&lt;p&gt;and now we very simply start up the database using the remote heroku machine with&lt;/p&gt;
&lt;pre class="prettyprint lang-bash"&gt;
heroku run python djangoapp/manage.py syncdb
&lt;/pre&gt;

&lt;p&gt;And we're there! Making a database user with a password finishes this round out.&lt;/p&gt;
&lt;h3&gt;Next Steps&lt;/h3&gt;

&lt;p&gt;Making models, templates, and so on as in the Mongo Tumblelog or do whatever you want!  You now have the base configuration to make a website.&lt;/p&gt;&lt;/div&gt;</description><category>django</category><category>mongodb</category><category>tutorial</category><category>web</category><guid>http://www.npcompleteheart.com/posts/django-nonrel-mongodb-mongohq-and-heroku.html</guid><pubDate>Thu, 14 Mar 2013 12:21:25 GMT</pubDate></item></channel></rss>